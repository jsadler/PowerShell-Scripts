
<#
.Synopsis
    This module is used to locate all systems that an identified individual has logged onto.
.DESCRIPTION
    This module will attempt to locate all the machines that a certain individual has logged onto.  An operator can use this in any Active Directory domain and only requires the operator to have admin access to the machines being scanned.  To speed up process, the module will split the array of computers into a number of jobs (interval specified by operator).  ICMP, remote registry, and remote WMI access must be allowed on the distant end machines for the scan to be successful.  Performance will vary from network to network.
.EXAMPLE
    Start-BloodHound -DishtingushedName "OU=Test,DC=domain,DC=Com" -SearchScope Subtree -UserPrinipleName john.doe@domain.com -NumberOfProcesses 2 -Outputfile C:\output.csv -force 
    This will run the module with all mandatory parameters filled in.  The Force switch will overwrite the targeted '.csv' file.  If the force switch is not specified, then it will error out attempting to run.
.NOTES
    
    Contact information - 561 Network Operations Squadron/Weapons and Tactics Shop

    WARNING:  This script comes with no warranty.  Test it first before deploying it to your production network.  Use at your own discretion.
    
    Revision Information:
    1.0 - Created by SSgt David Webster for the Area52 domain. Completely interactive however, limited to only the Area domain.  Output very limited.
    2.0 - April 28th, 2015 - Modified script to be dynamic for any domain.  Also modify WMI query to interact with directly with the .Net accelerator for quicker queries and also the ability for WMI time-outs.  Removed Log file.
    2.1 - April 29th, 2015 - Modified script to either be ran from a one line command or have the UI prompt the user for missing information.
    3.0 - May 4th, 2015    - Converted script into a module.  Improving error reporting.  Added in the parameters for Output File and the Force switch.  Cleaning up and finalizing help file/comments.
    3.1 - May 19th, 2015   - Added in a check to make sure the computer is running at least PowerShell 3.0 or higher.

#>
Function Start-BloodHound {
Param (
    #This is the top OU to start the search from.  Must be in the format of full Distinguished Name.  EX: Example:  OU=Test,DN=Domain,DN=COM"
    [Parameter(Mandatory=$true,
            Helpmessage="This is the top OU to start the search from.  This is the top OU to start the search from.  Must be in the format of full Distinguished Name.  EX: Example:  OU=Test,DN=Domain,DN=COM")]
            [ValidateScript({
                If($_ -notmatch "^OU=.*DC=.*DC=.*") {
                    Throw "The given format did not match the Distinguished Name Standard.  EX: Example:  OU=Test,DN=Domain,DN=COM."
                    }
                $OUSearcher = [ADSISearcher]""
                $OUSearcher.Filter = "(&(objectCategory=organizationalUnit)(objectClass=organizationalUnit)(name=*))"
                $OUSearcher.SearchRoot = "LDAP://$_"
                $OUSearcher.SearchScope = 'base'
                Try {
                    $DNTest = $OUSearcher.FindAll()
                    }
                Catch {}
                If($DNTest.properties.distinguishedname -match $_) {
                    $true
                    }
                Else {
                    Throw "The given Distinguished Name for the OU was not found in Active Directory."
                    }
                })]
            [string]$DishtingushedName,
    #This is the list to decided whether to perform a Subtree or OneLevel search when looking for computers. Onelevel will grab content from the immediate OU while Subtree will grab contents from all child OU in addition to the immediate OU.
    [Parameter(Mandatory=$true,
                Helpmessage="This is the list to decided whether to perform a Subtree or OneLevel search when looking for computers. Operator must type in Subtree or OneLevel")]
        [ValidateSet("Subtree","OneLevel")]
        [string]$SearchScope,
    #This is the user principle name of the subject in question.  Not the SAM account name or pre-2K.  EX:  john.doe@domain.com.
    [Parameter(Mandatory=$true,
                Helpmessage="This is the user principle name of the subject in question.  Not the SAM account name or pre-2K.")]
        [Validatescript({
            If($_ -notmatch '.*@.*') {
                Throw "Provide user principle name did not match the stardard.  EX:  john.smith@domain.com"
                }
	        $UserSearcher = [ADSISearcher]"(&(objectCategory=user)(objectClass=user)(userPrincipalName=$_))"
	        Try {
                $User = $UserSearcher.FindOne().GetDirectoryEntry()
                }
            Catch {}
	        If($user.properties.userPrincipalName -match $_) {
                $true
                }
            Else {
                Throw "The user principle name provided was not found in active directory."
                }          
            })]
        [string]$UserPrinipleName,
    #This is the number of processes to create to speed up the search.  It must be a positive whole number greater than 0. NOTE:  Ensure you have enough RAM for how many processes you create.  Average memory usage is about 32 to 50 MB per processes.
    [Parameter(Mandatory=$true,
               Helpmessage="This is the number of processes to create to speed up the search.  It must be a positive whole number greater than 0.  NOTE:  Ensure you have enough RAM for how many processes you create.  Average memory usage is about 32 to 50 MB per processes.")]
        [ValidateScript({
            If($_ -match '^[^0\D]\d*$') {
                $true
                }
            Else {
                Throw "It must be a positive number greater than 0."
                }
            })]
        [string]$NumberOfProcesses,
    #This is the location of the output file.  It can be absolute or relative path.  If a user does not specify a '.csv' extension, then this module will add it to the end.
    [parameter(Mandatory=$true,
               Helpmessage='This is the location of the output file.  It can be absolute or relative path.  It must have the .csv extension at the end.')]
        [string]$Outputfile,
    #This switch lets the user overwrite a '.csv' file.    
        [switch]$Force
    )

#########################################################
#Start of Variables
#########################################################

#//If Powershell is not running at least version 3, exit the script
If($PSVersionTable.PSVersion.Major -lt 3) {
    "Powershell needs to be at least version 3.0 or higher to run this module. Please look at the version number with the following command:  `$PSVersionTable.PSVersion.Major"
    Exit
    }

#// If the user provided output file does not have a .csv at the end, this will ensure that it does.
If($Outputfile -notlike "*.csv") {
    $Outputfile += '.csv'
    }

#// Ensures that the module does not over write an existing .csv file if the Force switch was not used.
If((Resolve-Path $Outputfile -ErrorAction SilentlyContinue) -and ($force -ne $true)) {
    throw "Output file $(resolve-path $Outputfile) already exists.  Please choose another file location, file name, or use the -force switch."
    break
    }

#########################################################
#End of Variables
#########################################################


#########################################################
#Start of Functions
#########################################################

#// Converts a EDIPI to a usable SID string
function Get-UserSID {
	param (
        [string]$UserNameInput
        )
	$UserSearcher = [ADSISearcher]"(&(objectCategory=user)(objectClass=user)(userPrincipalName=$UserNameInput*))"
	$User = $UserSearcher.FindOne().GetDirectoryEntry()
	$BinarySID = $User.ObjectSid.Value
	$UserSID = (New-Object System.Security.Principal.SecurityIdentifier($BinarySID,0)).Value
	$User.Dispose()
	return $UserSID
    }

#// Generates a list of computernames from a given base
function Get-Computers {
	param (
        [string]$DNInput, 
        [string]$Searchscope
        )
	$CompSearcher = [ADSISearcher]""
    $CompSearcher.Filter = "(&(objectCategory=computer)(objectClass=computer)(cn=*))"
	$CompSearcher.SearchRoot = "LDAP://$DNInput"
	$CompSearcher.PageSize = '1000'
    $CompSearcher.searchscope = $Searchscope
	$CompSearcher.PropertiesToLoad.AddRange('cn') | Out-Null
	$TempComps = $CompSearcher.FindAll()
	foreach ($Comp in $TempComps){
		[array]$BaseComps += $Comp.Properties.cn
	    }
	$BaseComps = $BaseComps | sort 
    return $BaseComps
    }

#// Splits an array into smaller arrays
function Split-Array {
    param(
        $InArray,
        $Parts
        )
    $PartSize = [Math]::Ceiling([int]$InArray.count / [int]$Parts)
    $OutArray = @()
    for ($i=1; $i -le $Parts; $i++) {
        $start = (($i-1) * $PartSize)
        $end = (($i) * $PartSize) - 1
        if ($End -ge $InArray.count) {$End = $InArray.count}
        $OutArray+=,@($InArray[$Start..$End])
        }
  return $OutArray
    }

#// Timer for the user display
function Stop-Timer {
    param (
        $StartTime
        )
    $StopTime = Get-Date
    $TimeDiff = $StopTime - $StartTime
    $Time = " ($($TimeDiff.Seconds).$($TimeDiff.Milliseconds)s)"
    return $Time
    }

#// Functions to pass to new jobs
$Function = {	
    #// Gets owner of specified process.  Uses try/catch here as there is no discovered way to suppress accelerator feedback without suppressing all errors for the module.
    function Get-ProcessOwner {
        param(
            $computer
            )
        Try {            
            [WmiSearcher]$a = "Select * from Win32_Process where name = 'explorer.exe'"
            $a.Scope.Path = "\\$Computer\root\cimv2"
            $a.Options.Timeout = '0:0:15'
            $gigId = $a.get().GetOwner().User
            try {
                return ([adsisearcher]"samaccountname=$gigId").FindOne().Properties.displayname
                }
            catch {
                return "None"
                }
            }
        Catch {
            return "None"
            }
        }

	#// Gets the registry key value on a computer
	function Get-RegInfo {
		param (
            $User,
            $Computer
            )
		Try {
            $Reg = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $Computer)
            if ($Reg.OpenSubKey("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\$User", $true)) {
                $CompLoc = ([adsisearcher]"(name=$Computer)").FindOne().Properties.location
		        }
            }
        Catch {}
        Return $CompLoc
	    }

    Function Get-LastLogon {
        param (
            $Computer,
            $User
            )
        try {
            $templine = "'$user'"
            [WmiSearcher]$a = "Select * from win32_userprofile where sid = $templine"
            $a.Scope.Path = "\\$Computer\root\cimv2"
            $a.Options.Timeout = '0:0:15'
            $TimeDate = $a.get()
            $Lastdate = get-date ([Management.ManagementDateTimeConverter]::ToDateTime("$($TimeDate.LastUseTime)")) -Format G
            Return $Lastdate
            }
        Catch {}
        }
	
	#// Checks that a computer responds to PINGs, checks the remote registry service and then attempts to run the Get-RegInfo function
	function Check-LogonList {
		param (
            $User,
            $Computer
            )
		If (Test-Connection -Count 1 -ComputerName $Computer -ErrorAction SilentlyContinue) {
			Try {
                $Service = Get-Service -Name 'RemoteRegistry' -ComputerName $Computer -ErrorAction Stop
                If ($Service.status -eq 'Running') {
				    Get-RegInfo -User $User -Computer $Computer
			        $startedService = $true
                    }
                }
            Catch {
                $ErrorReport = "Could not access remote registry"
                }
            If($startedService) {
                $ComputerResult = New-Object -TypeName psobject -Property @{
                    'Computer Name' = $Computer
                    'Computer Physical Location According to AD' = $(Get-RegInfo -User $User -Computer $Computer)
                    'Subject last logon' = $(Get-LastLogon -Computer $Computer -User $User)
                    'Current Logged on User' = $(Get-ProcessOwner -computer $Computer)
                    Error = $ErrorReport
                    }		    
                }
            Else {
                $ComputerResult = New-Object -TypeName psobject -Property @{
                    'Computer Name' = $Computer
                    Error = $ErrorReport
                    }	
                }
            }
        Else {
            $ComputerResult = New-Object -TypeName psobject -Property @{
                'Computer Name' = $Computer
                Error = "System not Pingable"
                }
            }
        return $ComputerResult
        }
    }

#########################################################
#End of Functions
#########################################################


#########################################################
#//Start of Main Scripts
#########################################################

#// Start basic output
"`n[BLOODHOUND] - Windows User Profile Locator `n" 
"Distinguished Name of $DishtingushedName is valid."
"You selected to perform a $SearchScope search scope" 
"User Principle name of $UserPrinipleName is valid." 
"You select to created $NumberOfProcesses processes."
"Output file will be created in the following location:  $Outputfile `n"

#// Queries Active Directory for the user's SID.
Write-Host "Gathering user's SID......." -NoNewLine
$Start = Get-Date
$UserSID = Get-UserSID -UserNameInput $UserPrinipleName
Write-Host "DONE" -NoNewline
Stop-Timer $Start
"User's SID is $UserSID `n"

#// Queries Active Directory for all the computer that are going to be scanned.
Write-Host "Gathering Computers......." -NoNewLine
$Start = Get-Date
$Computers = Get-Computers -DNInput $DishtingushedName -Searchscope $Searchscope
Write-Host "DONE" -NoNewline
Stop-Timer $Start
"$($Computers.count) identified computers to be scanned.`n"

#// Split gathered computers into multiple arrays.
$Arrays = Split-Array -InArray $Computers -Parts $NumberOfProcesses

#// Creates a new job for every array in $Arrays
Write-Host "Spawning $NumberOfProcesses Processes...." -NoNewLine
$start = Get-Date
foreach ($Array in $Arrays) {
	[array]$Jobs += Start-Job -InitializationScript $Function -ArgumentList @($Array, $UserSID) -ScriptBlock {
		param ([array]$Array, $UserSID)
		foreach ($Computer in $Array) {
			$ComputerResult = Check-LogonList -User $UserSID -Computer $Computer
		    [array]$Total += $ComputerResult
            $ComputerResult = $null
            }
	$Total
    }
}
Write-Host "DONE" -NoNewLine
Stop-Timer $Start

#// Wait for the jobs to finish running and receive the output
Write-Host "Waiting for jobs to finish......." -NoNewLine
$Start = Get-Date
$Output = $Jobs | Wait-Job | Receive-Job
Write-Host "DONE" -NoNewline
Stop-Timer $Start

#//  Create output file
Write-Host "Creating output file......." -NoNewLine
$Start = Get-Date
If($force) {
    $Output | select 'Computer Name','Subject last logon','Computer Physical Location According to AD','Current Logged on User',Error | Export-Csv $Outputfile -NoTypeInformation -force -ErrorAction SilentlyContinue
    }
Else {
    $Output | select 'Computer Name','Subject last logon','Computer Physical Location According to AD','Current Logged on User',Error | Export-Csv $Outputfile -NoTypeInformation -ErrorAction SilentlyContinue
    }
Write-Host "DONE" -NoNewLine
Stop-Timer $Start

#########################################################
#//End of Main Scripts
#########################################################
} 
